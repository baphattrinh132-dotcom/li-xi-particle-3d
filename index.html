```html
<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>L√¨ x√¨ Particle 3D</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#05050a; }
    canvas { display:block; }

    .ui{
      position:fixed; inset:0;
      display:flex; align-items:flex-start; justify-content:center;
      pointer-events:none;
      color:rgba(255,255,255,.92);
      font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .panel{
      margin-top:18px;
      width:min(680px, calc(100vw - 24px));
      background:rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:14px 14px;
      backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .title{ font-weight:700; letter-spacing:.2px; }
    .muted{ opacity:.85; }
    .badge{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.25);
      opacity:.95;
      font-size:12px;
    }
    input[type="text"]{
      flex:1;
      min-width:200px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.15);
      background:rgba(0,0,0,.35);
      color:rgba(255,255,255,.95);
      padding:10px 12px;
      outline:none;
    }
    button{
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:rgba(255,255,255,.95);
      padding:10px 12px;
      cursor:pointer;
    }
    button:hover{ background:rgba(255,255,255,.12); }
    .hint{ margin-top:8px; opacity:.85; }
  </style>
</head>
<body>
  <div class="ui">
    <div class="panel">
      <div class="row" style="justify-content:space-between;">
        <div class="title">üßß L√¨ x√¨ Particle 3D</div>
        <div class="badge">K√©o ƒë·ªÉ xoay ‚Ä¢ LƒÉn ƒë·ªÉ zoom ‚Ä¢ Click ƒë·ªÉ b√≥c</div>
      </div>

      <div id="nameRow" class="row" style="margin-top:10px;">
        <input id="nameInput" type="text" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n‚Ä¶" maxlength="32" />
        <button id="startBtn">B·∫Øt ƒë·∫ßu</button>
      </div>

      <div id="greetRow" class="muted" style="margin-top:10px; display:none;"></div>

      <div class="hint muted" id="statusHint" style="margin-top:10px;">
        Nh·∫≠p t√™n ‚Üí sau ƒë√≥ click v√†o bao l√¨ x√¨ ƒë·ªÉ ‚Äúb√≥c‚Äù.
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

    // =========================
    // 1) DANH S√ÅCH TH√îNG ƒêI·ªÜP (S·ª¨A ·ªû ƒê√ÇY)
    // =========================
    const WISHES = [
      "Ch√∫c b·∫°n nƒÉm m·ªõi an khang th·ªãnh v∆∞·ª£ng, v·∫°n s·ª± nh∆∞ √Ω!",
      "Ch√∫c b·∫°n h·ªçc gi·ªèi ‚Äì ƒëi·ªÉm cao ‚Äì thi ƒë√¢u ƒë·∫≠u ƒë√≥!",
      "Ch√∫c b·∫°n s·ª©c kh·ªèe d·ªìi d√†o, gia ƒë√¨nh h·∫°nh ph√∫c, ti·ªÅn v√†o nh∆∞ n∆∞·ªõc!",
      "Ch√∫c b·∫°n lu√¥n vui v·∫ª, t·ª± tin, l√†m g√¨ c≈©ng thu·∫≠n l·ª£i v√† g·∫∑p nhi·ªÅu may m·∫Øn!",
      "Ch√∫c b·∫°n m·ªôt nƒÉm m·ªõi b·ª©t ph√°, ƒë·∫°t ƒë∆∞·ª£c m·ª•c ti√™u v√† c√≥ th·∫≠t nhi·ªÅu tr·∫£i nghi·ªám ƒë·∫πp!"
    ];

    // =========================
    // 2) UI
    // =========================
    const nameRow = document.getElementById("nameRow");
    const greetRow = document.getElementById("greetRow");
    const statusHint = document.getElementById("statusHint");
    const nameInput = document.getElementById("nameInput");
    const startBtn = document.getElementById("startBtn");

    let userName = "";
    let hasStarted = false;
    let hasOpened = false;

    function pickRandomWish(){
      return WISHES[(Math.random() * WISHES.length) | 0];
    }

    function startFlow(){
      const raw = (nameInput.value || "").trim();
      userName = raw.length ? raw : "b·∫°n";
      hasStarted = true;

      nameRow.style.display = "none";
      greetRow.style.display = "block";
      greetRow.textContent = `G·ª≠i ${userName}, m·ªùi b·∫°n b√≥c phong th∆∞ (click v√†o bao l√¨ x√¨).`;
      statusHint.textContent = "Click v√†o bao l√¨ x√¨ ƒë·ªÉ m·ªü l√¨ x√¨ ‚ú®";
    }

    startBtn.addEventListener("click", startFlow);
    nameInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter") startFlow(); });

    // =========================
    // 3) THREE SETUP
    // =========================
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.10;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x070713, 0.030);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 280);
    camera.position.set(0.9, 3.6, 14.5);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 8;
    controls.maxDistance = 60;
    controls.target.set(0, 2.8, 0);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      0.75,
      0.25,
      0.23
    );
    composer.addPass(bloom);

    // =========================
    // 4) GLOW TEXTURE
    // =========================
    function makeGlowTexture(){
      const s = 160;
      const c = document.createElement("canvas");
      c.width = c.height = s;
      const g = c.getContext("2d");
      const grd = g.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
      grd.addColorStop(0.0, "rgba(255,255,255,1)");
      grd.addColorStop(0.18, "rgba(255,255,255,0.95)");
      grd.addColorStop(0.45, "rgba(255,255,255,0.35)");
      grd.addColorStop(1.0, "rgba(255,255,255,0)");
      g.fillStyle = grd;
      g.fillRect(0,0,s,s);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
    const glowTex = makeGlowTexture();

    // =========================
    // 5) STARFIELD (D√ÄY)
    // =========================
    function createStars(count = 42000){
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);

      for(let i=0;i<count;i++){
        const r = 170;
        const d = Math.random();
        const rr = r * Math.pow(d, 0.25);

        const a = Math.random() * Math.PI * 2;
        const b = Math.acos(2 * Math.random() - 1);

        const x = rr * Math.sin(b) * Math.cos(a);
        const y = rr * Math.cos(b);
        const z = rr * Math.sin(b) * Math.sin(a);

        positions[i*3+0] = x;
        positions[i*3+1] = y;
        positions[i*3+2] = z;

        const brightness = (Math.random() < 0.18) ? 1.0 : (0.35 + Math.random()*0.4);
        colors[i*3+0] = 0.85 * brightness;
        colors[i*3+1] = 0.90 * brightness;
        colors[i*3+2] = 1.00 * brightness;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.12,
        map: glowTex,
        transparent: true,
        depthWrite: false,
        depthTest: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
        opacity: 0.95
      });

      return new THREE.Points(geo, mat);
    }
    scene.add(createStars());

    // =========================
    // 6) SHADER POINT MATERIAL
    // =========================
    function makePointsMaterial({ baseSize = 170, twinkle = 0.9 } = {}) {
      return new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        uniforms: {
          uMap: { value: glowTex },
          uTime: { value: 0 },
          uPixelRatio: { value: Math.min(devicePixelRatio, 2) },
          uBaseSize: { value: baseSize },
          uTwinkle: { value: twinkle }
        },
        vertexShader: `
          attribute float aSize;
          attribute vec3 color;
          varying vec3 vColor;
          uniform float uTime;
          uniform float uPixelRatio;
          uniform float uBaseSize;
          uniform float uTwinkle;

          void main(){
            vColor = color;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);

            float tw = 1.0;
            if (uTwinkle > 0.0) {
              tw = 0.88
                + 0.16 * sin(uTime * 2.0 + position.x * 2.8 + position.y * 1.4)
                + 0.06 * sin(uTime * 5.0 + position.z * 5.2);
              tw = mix(1.0, tw, uTwinkle);
            }

            gl_PointSize = (uBaseSize * aSize * tw) * uPixelRatio * (1.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          uniform sampler2D uMap;
          varying vec3 vColor;

          void main(){
            vec4 tex = texture2D(uMap, gl_PointCoord);
            float core = pow(tex.a, 0.42);
            vec3 col = vColor * (1.35 + 1.75 * core);
            gl_FragColor = vec4(col, core);
          }
        `
      });
    }

    // =========================
    // 7) ENVELOPE OUTLINE (PARTICLES)
    // =========================
    function buildEnvelopePointsOutline({
      count = 17000,
      w = 6.0,
      h = 8.0,
      thickness = 0.18,
      centerY = 2.8
    } = {}) {
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const sizes = new Float32Array(count);

      const red = new THREE.Color("#ff2b2b");
      const gold = new THREE.Color("#ffd24a");

      const bodyTopY = h/2;
      const bodyBottomY = -h/2 + h*0.25;
      const innerY = h/2 - h*0.38;

      function edgePoint(x, y) {
        return {
          x: x + (Math.random()*2-1)*0.035,
          y: y + (Math.random()*2-1)*0.035,
          z: (Math.random()*2-1)*thickness
        };
      }

      function edge(x1,y1,x2,y2,t){
        return { x: x1 + (x2-x1)*t, y: y1 + (y2-y1)*t };
      }

      for (let i=0;i<count;i++){
        const ix = i*3;
        const r = Math.random();
        let p2;

        if (r < 0.78) {
          const t = Math.random();
          const pick = Math.random();

          if (pick < 0.22) {
            const p = edge(-w/2, bodyBottomY, -w/2, bodyTopY, t);
            p2 = edgePoint(p.x, p.y);
          } else if (pick < 0.44) {
            const p = edge(w/2, bodyBottomY, w/2, bodyTopY, t);
            p2 = edgePoint(p.x, p.y);
          } else if (pick < 0.62) {
            const p = edge(-w/2, bodyBottomY, w/2, bodyBottomY, t);
            p2 = edgePoint(p.x, p.y);
          } else {
            const p = edge(-w/2, bodyTopY, w/2, bodyTopY, t);
            p2 = edgePoint(p.x, p.y);
          }
        } else {
          const t = Math.random();
          const A = { x: -w/2, y: bodyTopY };
          const B = { x:  w/2, y: bodyTopY };
          const C = { x: 0.0,  y: innerY };
          const which = (Math.random() < 0.5);
          const E0 = which ? A : C;
          const E1 = which ? C : B;
          const p = edge(E0.x, E0.y, E1.x, E1.y, t);
          p2 = edgePoint(p.x, p.y);
        }

        positions[ix+0] = p2.x;
        positions[ix+1] = p2.y + centerY;
        positions[ix+2] = p2.z;

        const isGold = Math.random() < 0.12;
        const c = isGold ? gold : red;
        const boost = isGold ? 2.15 : 1.55;

        colors[ix+0] = c.r * boost;
        colors[ix+1] = c.g * boost;
        colors[ix+2] = c.b * boost;

        sizes[i] = isGold ? (0.30 + Math.random()*0.35) : (0.10 + Math.random()*0.22);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      geo.setAttribute("aSize", new THREE.BufferAttribute(sizes, 1));

      const mat = makePointsMaterial({ baseSize: 175, twinkle: 0.9 });
      const pts = new THREE.Points(geo, mat);

      pts.userData.envelopeBounds = { w, h, centerY };
      return { pts, mat };
    }

    // Group (s·∫Ω ƒë·ª©ng y√™n sau khi m·ªü)
    const envelopeGroup = new THREE.Group();
    scene.add(envelopeGroup);

    const envelope = buildEnvelopePointsOutline({ count: 17000, w: 6.0, h: 8.0, thickness: 0.18, centerY: 2.8 });
    envelopeGroup.add(envelope.pts);

    // =========================
    // 7.5) CH·ªÆ "CUS" (1 M·∫∂T) - bi·∫øn m·∫•t khi m·ªü
    // =========================
    function makeTextPlane(text){
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 1024;
      canvas.height = 512;

      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.font = "900 140px system-ui, Segoe UI, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.shadowColor = "rgba(255,210,74,0.9)";
      ctx.shadowBlur = 40;
      ctx.fillStyle = "#ffd24a";
      ctx.fillText(text, canvas.width/2, canvas.height/2);

      ctx.shadowColor = "rgba(255,80,0,0.6)";
      ctx.shadowBlur = 80;
      ctx.fillText(text, canvas.width/2, canvas.height/2);

      ctx.shadowBlur = 0;
      ctx.fillText(text, canvas.width/2, canvas.height/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;

      const mat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        depthWrite: false
      });

      const geo = new THREE.PlaneGeometry(6.8, 3.2);
      return new THREE.Mesh(geo, mat);
    }

    const cusText = makeTextPlane("CUS");
    cusText.position.set(0, 2.3, 0.65);
    envelopeGroup.add(cusText);

    // =========================
    // 7.6) WISH TEXT (1 M·∫∂T) - fade in + cƒÉn d√≤ng trong khung
    // =========================
    function wrapLines(ctx, text, maxWidth){
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";
      for (const w of words) {
        const test = line ? (line + " " + w) : w;
        const m = ctx.measureText(test).width;
        if (m <= maxWidth || !line) line = test;
        else { lines.push(line); line = w; }
      }
      if (line) lines.push(line);
      return lines.slice(0, 4); // t·ªëi ƒëa 4 d√≤ng
    }

    function makeWishPlaneDynamic({
      w = 11.6,
      h = 4.2,
      font = "900 86px system-ui, Segoe UI, Arial",
      fill = "#ffd24a"
    } = {}) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 2048;
      canvas.height = 1024;

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;

      const mat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        depthWrite: false,
        opacity: 0.0
      });

      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);

      mesh.userData._canvas = canvas;
      mesh.userData._ctx = ctx;
      mesh.userData._tex = tex;
      mesh.userData._font = font;
      mesh.userData._fill = fill;

      mesh.userData.setWish = (text)=>{
        const c = mesh.userData._canvas;
        const g = mesh.userData._ctx;

        g.clearRect(0,0,c.width,c.height);

        // n·ªÅn trong su·ªët, ch·ªâ ch·ªØ glow
        g.font = mesh.userData._font;
        g.textAlign = "center";
        g.textBaseline = "middle";

        const padX = 160;
        const maxW = c.width - padX*2;

        // wrap
        const lines = wrapLines(g, text, maxW);

        // canh gi·ªØa theo t·ªïng chi·ªÅu cao
        const lineH = 116;
        const totalH = lines.length * lineH;
        let y = c.height/2 - totalH/2 + lineH/2;

        // glow nhi·ªÅu l·ªõp
        for (let pass=0; pass<3; pass++){
          if (pass === 0) { g.shadowColor = "rgba(255,210,74,0.92)"; g.shadowBlur = 44; g.fillStyle = fill; }
          if (pass === 1) { g.shadowColor = "rgba(255,120,0,0.65)"; g.shadowBlur = 90; g.fillStyle = fill; }
          if (pass === 2) { g.shadowColor = "rgba(0,0,0,0)"; g.shadowBlur = 0; g.fillStyle = fill; }

          y = c.height/2 - totalH/2 + lineH/2;
          for (const ln of lines){
            g.fillText(ln, c.width/2, y);
            y += lineH;
          }
        }

        mesh.userData._tex.needsUpdate = true;
      };

      mesh.userData.setWish(" ");
      return mesh;
    }

    const wishPlane = makeWishPlaneDynamic({
      w: 12.2,
      h: 4.6,
      font: "900 86px system-ui, Segoe UI, Arial"
    });
    // ƒë·∫∑t l√™n ‚Äút·ªù gi·∫•y‚Äù
    wishPlane.position.set(0, 2.9, 0.92);
    envelopeGroup.add(wishPlane);

    let wishTargetOpacity = 0.0;

    // =========================
    // 8) MORPH -> PAPER OUTLINE (GI·∫§Y L·ªöN H∆†N)
    // =========================
    function makeMorphToPaperOutline(points, {
      paperW = 11.8,
      paperH = 7.2,
      thickness = 0.16,
      morphSpeed = 7.5,
      center = new THREE.Vector3(0, 2.9, 0),
      zFront = 0.55
    } = {}) {

      const posAttr = points.geometry.getAttribute("position");
      const count = posAttr.count;

      const base = new Float32Array(posAttr.array);
      const paper = new Float32Array(count * 3);

      function edge(x1,y1,x2,y2,t){
        return { x: x1 + (x2-x1)*t, y: y1 + (y2-y1)*t };
      }
      function jitter(v, j=0.03){
        return v + (Math.random()*2-1)*j;
      }

      const halfW = paperW/2;
      const halfH = paperH/2;

      for (let i=0;i<count;i++){
        const ix = i*3;
        const t = Math.random();
        const pick = Math.random();

        let p;
        if (pick < 0.25) p = edge(-halfW, -halfH, -halfW, halfH, t);
        else if (pick < 0.50) p = edge(halfW, -halfH, halfW, halfH, t);
        else if (pick < 0.75) p = edge(-halfW, -halfH, halfW, -halfH, t);
        else p = edge(-halfW, halfH, halfW, halfH, t);

        paper[ix+0] = jitter(p.x, 0.040) + center.x;
        paper[ix+1] = jitter(p.y, 0.040) + center.y;
        paper[ix+2] = (Math.random()*2-1)*thickness + zFront;
      }

      points.userData.__morph2 = {
        posAttr, count, base, paper,
        mode: "base",
        mix: 0,
        morphSpeed
      };

      points.userData.toPaper = ()=>{ points.userData.__morph2.mode = "paper"; };
      points.userData.updateMorph2 = (dt)=>{
        const st = points.userData.__morph2;
        const arr = st.posAttr.array;

        const target = (st.mode === "paper") ? 1 : 0;
        st.mix += (target - st.mix) * (1.0 - Math.exp(-st.morphSpeed * dt));

        for (let i=0;i<st.count;i++){
          const ix = i*3;
          const bx = st.base[ix+0], by = st.base[ix+1], bz = st.base[ix+2];
          const px = st.paper[ix+0], py = st.paper[ix+1], pz = st.paper[ix+2];

          arr[ix+0] = bx + (px - bx) * st.mix;
          arr[ix+1] = by + (py - by) * st.mix;
          arr[ix+2] = bz + (pz - bz) * st.mix;
        }

        st.posAttr.needsUpdate = true;
      };
    }

    makeMorphToPaperOutline(envelope.pts, {
      paperW: 11.8,
      paperH: 7.2,
      thickness: 0.16,
      morphSpeed: 7.5,
      center: new THREE.Vector3(0, 2.9, 0),
      zFront: 0.55
    });

    // =========================
    // 9) CLICK HIT TEST
    // =========================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);

    function hitEnvelope(clientX, clientY){
      mouse.x = (clientX / innerWidth) * 2 - 1;
      mouse.y = -(clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const p = new THREE.Vector3();
      if (!raycaster.ray.intersectPlane(plane, p)) return false;

      const b = envelope.pts.userData.envelopeBounds;
      const halfW = b.w / 2;
      const halfH = b.h / 2;

      const localX = p.x;
      const localY = p.y - b.centerY;

      return (localX >= -halfW && localX <= halfW && localY >= -halfH && localY <= halfH);
    }

    // =========================
    // 10) OPEN
    // =========================
    let stopRotation = false;

    function openEnvelope(){
      if (!hasStarted || hasOpened) return;
      hasOpened = true;

      // d·ª´ng xoay sau khi m·ªü
      stopRotation = true;

      // ·∫©n CUS
      cusText.visible = false;

      // morph th√†nh t·ªù gi·∫•y (khung)
      envelope.pts.userData.toPaper();

      // set l·ªùi ch√∫c (d·∫°ng √°nh ƒë√®n) + fade in
      const wish = pickRandomWish();
      wishPlane.userData.setWish(wish);
      wishTargetOpacity = 1.0;

      statusHint.textContent = "‚ú® L·ªùi ch√∫c ƒëang hi·ªán l√™n‚Ä¶";
      greetRow.textContent = `G·ª≠i ${userName}, b·∫°n ƒë√£ b√≥c l√¨ x√¨ r·ªìi!`;
    }

    window.addEventListener("pointerdown", (e)=>{
      if (!hasStarted) return;
      if (!hasOpened && hitEnvelope(e.clientX, e.clientY)) openEnvelope();
    });

    // =========================
    // 11) ANIMATE
    // =========================
    const clock = new THREE.Clock();
    let tAcc = 0;

    function animate(){
      const dt = Math.min(clock.getDelta(), 0.033);
      tAcc += dt;

      if (!stopRotation) envelopeGroup.rotation.y = tAcc * 0.20;

      envelope.mat.uniforms.uTime.value = tAcc;
      envelope.pts.userData.updateMorph2(dt);

      // fade in l·ªùi ch√∫c
      const sp = 1.55;
      wishPlane.material.opacity += (wishTargetOpacity - wishPlane.material.opacity) * (1.0 - Math.exp(-sp * dt));

      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    }
    animate();

    // =========================
    // 12) RESIZE
    // =========================
    addEventListener("resize", ()=>{
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);

      const pr = Math.min(devicePixelRatio, 2);
      envelope.mat.uniforms.uPixelRatio.value = pr;
      bloom.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
```
